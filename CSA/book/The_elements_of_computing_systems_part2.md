# Part 2. 불 연산
> 1장에서 만든 논리 게이트들로부터 온전히 동작하는 산술 논리 연산 장치(ALU)를 완성하는 것을 목적으로 한다

### 1. 2진수
> 2진법은 기수(base)를 2로 한다  
> ex) 10011 = 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 19
##### 2진 덧셈
1. 최하위 비트(LSB)부터 더한다
1. 자리올림 비트(carry)를 다음 순서의 비트 쌍의 합에 더해준다
1. 최상위 비트(MSB)까지 반복한다
1. 만약, 마지막 비트를 더하고 나서도 자리올림수가 1이라면 오버플로가 발생한다
##### 부호가 있는 2진수
> 2의 보수의 법 : n개의 숫자로 된 2진수 x가 있을 때, x의 2의 보수는 다음과 같이 정의한다
>> x' = 2^n - x (if x!=0) , 0 (otherwise)

일반적으로 2의 보수법을 n비트 숫자에 적용하면 `x + (-x)`는 항상 2^n이 된다
- 이와 같은 방식으로 총 2^n개의 부호 있는 숫자 표현이 가능하며, 최댓값 및 최솟값은 `2^(n-1) -1` 과 `-2^(n-1)`
- 모든 양수 코드는 0으로 시작한다
- 모든 음수 코드는 1로 시작한다
- x에서 -x를 구하려면 2진수 맨 뒤에서부터 연속된 0들과 첫번째로 나타나는 최하위 비트 1은 그대로 두고 나머지 비트들을 모두 뒤집으면 된다(또는 모든 비트를 뒤집고 1을 더하는 방법이 있다)
### 2. 명세
##### 반가산기
	칩 이름 : HalfAdder
	입력 : a, b
	출력 : sum, carry
	기능 : sum = a + b의 LSB(최하위 비트)
		carry = a + b의 MSB(최상위 비트)
##### 전가산기
	칩 이름 : FullAdder
	입력 : a, b, c
	출력 : sum, carry
	기능 : sum = a + b + c의 LSB
		carry = a + b + c의 MSB
##### 16비트 가산기
	칩 이름 : Add16
	입력 : a[16], b[16]
	출력 : out[16]
	기능 : out = a + b
	설명 : 정수의 2의 보수 덧셈 오버플로는 감지나 처리가 되지 않는다
##### 증분기
	칩 이름 : Inc16
	입력 : in[16]
	출력 : out[16]
	기능 : out = in + 1
	설명 : 정수의 2의 보수 덧셈 오버플로는 감지나 처리가 되지 않는다

