# Network Chapter 6 : 멀리 있는 컴퓨터끼리는 이렇게 데이터를 주고받는다

## 1. IPv4프로토콜

> 20바이트, 네트워크 대역을 찾아가는 프로토콜

### IPv4가 하는 일

네트워크 상에서 데이터를 교환하기 위한 프로토콜

데이터가 **정확하게 전달될 것을 보장하지 않는다**

중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성도 있다 (악의적으로 이용되면 DoS공격이 됨)

데이터의 정확하고 순차적인 전달은 그보다 상위 프로토콜인 TCP에서 보장한다

### IPv4 프로토콜의 구조

다른 네트워크의 특정 대상을 찾는 IPv4 프로토콜

<img src="/Users/yangsiseon/Desktop/TIL/asset/img/Screenshot 2022-12-29 at 8.14.40 PM.png" alt="Screenshot 2022-12-29 at 8.14.40 PM" style="zoom:50%;" />

> IP Option의 경우, 추가적으로 붙을 수도 있는 부분임
>
> > 없을 경우 기본적으로 20byte / 최대 10개의 옵션이 붙을 수 있으므로 60byte까지 늘어남

- Version(4bit) : 무조건 16진수 4가 할당됨

  > 6버전의 경우, 구조가 완전히 바뀐 형태이므로 구성이 다름

- HL(Header Length)(4bit) : 헤더의 길이 &rarr; 20byte ~ 60byte

  > 크기가 4bit밖에 안되므로 해당 길이의 4를 나눈 값을 기입함(5~15)

- Type of Service(TOS)(1byte) : 현재는 사용하지 않음 &rarr; 0으로 할당

- Total Length(2byte) : 헤더와 페이로드를 합친 전체 패킷의 길이

- Identification & IP Flags & Fragment Offset (2byte) : 데이터가 쪼개질때 각각을 식별하기 위해서 사용하는 부분

  > identification : 동일한 데이터라면 패킷이 쪼개지더라도 동일한 id를 가지고 있음
  >
  > Flags : 3bit로 되어있으며 처음 1bit은 사용하지 않음 / D : 데이터가 조각화 되어있지 않음을 의미(너무 큰 데이터면 전송에 실패함) / M : 뒤에 아직 조각화된 데이터가 남아있음을 의미
  >
  > Fragment Offset : 13bit로 되어있으며, 조각화된 데이의 순서를 기입하는 부분 (8로 나눈 값이 들어감)
  >
  > > 패킷은 항상 순서가 정확하게 전달되지 않음 즉, 패킷의 순서가 꼬일 수 있으므로 순서를 식별하기 위한 정보가 필요함

- Time To Live(TTL)(1byte) : 패킷이 생존할 수 있는 시간(네트워크 장비의 경로가 잘못 설정되었을 경우, 패킷이 죽지않으면 부하가 커질 수 있음)

- Protocol(1byte) : 상위 프로토콜 정보(ICMP : 1(0x01), TCP : 6(0x06), UDP : 17(0x11))

- Header Checksum(2byte) : 헤더가 오류가 있는지 확인하는데 사용

- Source Address(4byte) : 출발지의 IP주소
- Desitination Address(4byte) : 목적지의 IP주소

## 2. ICMP프로토콜

### ICMP가 하는 일

ICMP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)

네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송 받는데 주로 쓰인다

프로토콜 구조의 Type과 Code를 통해 오류 메시지를 전송 받는다

### ICMP 프로토콜의  구조

특정 대상과 내가 통신이 잘되는지 확인하는 ICMP프로토콜<img src="/Users/yangsiseon/Desktop/TIL/asset/img/Screenshot 2022-12-29 at 9.06.30 PM.png" alt="Screenshot 2022-12-29 at 9.06.30 PM" style="zoom:50%;" />

- Type(1byte) : 대분류

  > 대표적인 type
  >
  > 0(echo reply) : 응답
  >
  > 8(echo) : 요청
  >
  > 3(destination unreachable) : 목적지까지 도달하지 못함 (경로상에 문제)
  >
  > 11(time exceded) : 도착했으나 응답을 받지 못함 (상대방에 문제)
  >
  > 5(source route failed) : 상대방의 라우팅 테이블을 원격으로 수정할 때 사용

- Code(1byte) : 소분류

- Checksum(2byte) : 헤더에 오류가 있는지 확인하는데 사용



## 3. 라우팅 테이블

### 내가 보낸 패킷은 어디로 가는가

어디로 보내야 하는지 설정되어 있는 라우팅 테이블

> `netstat -r`로 라우팅 테이블 확인가능
>
> > 라우팅 테이블에 작성된 네트워크 대역만 찾아갈 수 있음
> >
> > > 네트워크 대역을 모를 수도 있기 때문에 0.0.0.0과 같은 네트워크 대역을 기본 설정을 넣어놓음

## 4. 다른 네트워크와 통신 과정

### 다른 네트워크까지 내 패킷의 이동 과정

<img src="/Users/yangsiseon/Desktop/TIL/asset/img/Screenshot 2022-12-29 at 9.50.33 PM.png" alt="Screenshot 2022-12-29 at 9.50.33 PM" style="zoom:50%;" />

> A에서 B로 ping을 보내고자 함

1. A의 라우팅 테이블 확인 &rarr; B의 네트워크 대역이 있어야만 찾아갈 수 있음

2. A에서 프로토콜을 작성 : \[eth]\[IPv4]\[ICMP요청]

   > 이때 eth에 셋팅되는 목적지 MAC주소는 **동일 네트워크** 내 게이트웨이 MAC주소임(eth는 동일네트워크 내에서만 통신하므로)

3. 스위치는 eth프로토콜을 확인하고 게이트웨이로 올려보냄

4. 게이트웨이는 eth프로토콜을 확인하고 자신에게 왔음을 확인 후 IPv4프로토콜을 확인&rarr; 해당 목적지 IP를 본인의 라우팅 테이블에서 찾아봄

5. 라우팅 테이블에 의해 인접 라우터로 데이터를 보내기 전, 해당 네트워크 대역에 맞도록 eth프로토콜을 재작성함

6. 인접 라우터는 해당 패킷의 eth프로토콜을 확인하여 자신에게 왔음을 확인 후 IPv4프로토콜을 확인 &rarr; 본인의 라우팅 테이블 확인

7. 다시 eth프로토콜을 재작성 후 라우팅 테이블에 작성된 라우터로 전송

8. 위의 과정을 반복하며 원하는 네트워크 대역까지 전송

9. B까지 도달하면 eth, IPv4를 순차적으로 확인 후 ICMP요청 프로토콜을 확인

10. \[eth]\[IPv4]\[ICMP 응답] 프로토콜을 작성하여 역으로 A한테 보냄

cf) 각 과정마다 네트워크 장비들 간 MAC주소를 모르면 ARP프로토콜을 보내는 과정이 중간중간 추가될 수 있음

## 5. IPv4의 조각화

### 조각화란?

큰 IP 패킷들이 적은 MTU(Maximum Transmission Unit)를 갖는 링크를 통하여 전송되려면 여러 개의 작은 패킷으로 쪼개어/조각화 되어 전송돼야 한다

즉, 목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마타 전송에 적합한 프레임으로 변환이 필요하다

일단 조각화되면, 최종 목적지에 도달할 때까지 재조립되지 않은 것이 일반적이다

IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화가 가능

IPv6에서는 IP 단편화가 발신지에서 만 가능

재조립은 항상 최종 수신지에서만 가능함

### 조각화하는 과정

ping명령어 사용 / MTU의 최대값 : 1500 / 보내고자 하는 데이터의 크기 : 2000 이라고 가정

Case1

1. 프로토콜 작성 \[ICMP요청]\[Data] (2000+8) &rarr; \[IPv4]\[ICMP요청]\[Data] (2000 + 8 +20) 
2. 최종 패킷의 크기 : 2028 > MTU : 1500 이므로 전송실패

Case2

1. 데이터를 1480, 520으로 쪼갬

2. 프로토콜 작성  \[IPv4]\[Data] (1480 + 50) &  \[IPv4]\[ICMP요청]\[Data] (520 + 8 + 20)

   > IP프로토콜은 각각 동일하게 캡슐화됨

3.  MTU 1500이하에 해당하므로 2개의 패킷 모두 전송가능

4. eth프로토콜은 MTU최대값 검증 이후에 붙음 따라서 패킷크기는 각각 1514, 562가 최종 크기

## 6. 따라學it

### 라우팅 테이블 확인해보기

### 패킷 분석하기