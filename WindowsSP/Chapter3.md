# System Programming Chapter 3 : 64비트 기반 프로그래밍
### 1. WIN32 vs WIN64
- 64비트와 32비트의 구분 방법
	> 아래 두가지 기준을 모두 동일하게 만족해야 완벽하게 n비트 시스템이라고 말할 수 있음
	- 구분의 두 가지 기준
		- 한번에 송수신 가능한 데이터 크기
			> BUS에 의존적
		- 데이터 처리 능력
			> CPU가 한번에 읽어들일 수 있는 명령어의 크기

### 2. 프로그램 구현 관점에서의 WIN32 vs WIN64
- 프로그래머 입장에서의 64비트 컴퓨터
	- 32비트 --> 64비트
		> 일반적으로 32bit시스템에서는 32bit 크기의 ptr사용 / 64bit시스템에서는 64bit 크기의 ptr사용
		>> ptr의 크기가 크다는 것은 램에서 접근가능한 영역이 크다는 의미 --> 주소로 사용할 수 있는 범위가 커짐
		>>> ex) 만약 4bit 크기의 ptr만 사용 가능하다면 아무리 메인메모리(RAM)가 크더라도 주소는 0000 ~ 1111 단 16개만 사용가능
		- 프로그램으로 표현할 수 있는 범위의 증가
		> ptr의 크기가 32bit일 경우 최대로 접근 가능한 RAM의 크기 : 2^32 = 4GB / 64bit : 0 ~ 2^64 - 1(굉장히 큼)
		- 표현할 수 있는 메모리의 전체 크기
		> ptr의 크기는 클수록 좋지만 버스보다 커지면 한개의 명령어를 한번에 옮길 수 없게되므로 버스의 크기와 맞춰주는 것이 best
- 64비트 기반 프로그래밍
	- 64비트 기반 프로그래밍
		- 64비트 시스템을 고려한 프로그래밍으로 자료형에 대해서 고려해야 한다
	- LLP64 vs LP64
		- 32비트 시스템과의 호환성을 중시한 모델

			|운영체제|모델|char|short|int|long|포인터|
			|---|---|---|---|---|---|---|
			|windows|LLP64|1바이트|2바이트|4바이트|4바이트|8바이트|
			|UNIX|LP64|1바이트|2바이트|4바이트|8바이트|8바이트|
- 64비트와 32비트 공존의 문제점
	- 데이터 손실의 문제
		```c
		#include <stdio.h>
		int main(void)
		{
			int arr[10] = {0,};
			// 배열의 이름은 곧 포인터이며 64bit시스템에서는 8byte크기를 가짐
			int arrVal = (int)arr;		//데이터 손실이 발생할 수 있는 위치
			// int형으로 강제 형변환시 64bit에서는 문제가 될 수 있음
			// 32bit에서는 포인터도 4byte, int형도 4byte로 동일
			printf("pointer : %d \n", arrVall);
			return 0;
		}
		```

### 3. 오류의 확인
- 함수호출의 성공여부 확인의 기본
	- GetLastError 함수 호출
		> 기본적으로 error발생시 전역공간에 해당 에러가 저장됨 / 해당 전역공간에 접근해주는 함수라고 할 수 있음
