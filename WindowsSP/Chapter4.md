# System programming Chapter 4 : 컴퓨터 구조에 대한 두 번째 이야기
### 1. 컴퓨터 구조의 접근방법
- 컴퓨터를 디자인 하자
	> 가상의 CPU를 디자인 해보자
	>> 내부 구조적으로 봤을 때 GPU도 CPU의 일종으로 볼 수 있음
	- 프로그래머 관점
		- 컴퓨터 구조를 잘 아는 프로그래머도 컴퓨터 디자인에 참여
			> CPU디자인에 있어서 각종 H/W전문가, interface전문가, 해당 algorithm전문가 뿐만 아니라 프로그래머도 참여함
		- 컴퓨터 디자인은 레지스터와 명령어 디자인
			> 명령어 디자인이 선행되어야 레지스터 셋 구성이 나옴
	- 레지스터 디자인의 핵심
		- 레지스터는 몇 비트로 구성할 것인가?
			> 해당 시스템 bit수와 동일함(n bit시스템이라면 레지스터 크기는 n bit)
			>> 해당 강의에서는 16bit로 진행하도록 함
		- 몇 개 정도로 레지스터를 구성할 것인가?
			> 해당 강의에서는 r0 ~ r7까지 8개로 구성하도록 함
		- 레지스터 각각을 무슨 용도로 사용할 것인가?
			> 레지스터는 다른 메모리처럼 범용적으로 사용하기 보다는 반드시 특정 목적에 부합되어 사용됨
			>> 특정목적에 따라 분류될 시, 명령어가 단순해지며 속도가 빨라지는 이점이 있음
			- r0 ~ r3 : 범용 레지스터(연산을 위함)
			- r4 : ir(instruction register)
			- r5 : sp(stack pointer)
			- r6 : lr(link register)
			- r7 : pc(program counter)
- 명령어 구조 및 명령어 디자인
	- 명령어의 기본 모델
		- 16비트 명령어
			> 16비트 시스템 기반이므로 명령어도 동일한 bit수를 사용함
	- 사칙연산 명령어 구성
		
		`| 예약(2bit) | 연산자(3bit) | 저장소(3bit) | 피연산자1(4bit) | 피연산자2(4bit) |`
		> 사칙연산 명령어 구조(명령어에 따라서 구조는 달라질 수 있음)
		- 저장소 : 레지스터
		- 피연산자 1, 2 : 레지스터 or 숫자
			> 레지스터 인지 숫자인지 구분하기 위해서 피연산자의 첫번째 비트를 구분자로 지정하는 방식을 사용
		
		|연산의 의미|심볼|2진 코드|
		|---|---|---|
		|덧셈|ADD|001|
		|뺄셈|SUB|010|
		|곱셈|MUL|011|
		|나눗셈|DIV|100|

		|레지스터 심볼|2진 코드|
		|---|---|
		|r0|000|
		|r1|001|
		|r2|010|
		|r3|011|
		|r4, ir|100|
		|r5, sp|101|
		|r6, lr|110|
		|r7, pc|111|
- RISK(reduced) vs CISK(complex)
	- CISK : 다양한 명령어 조합으로 프로그래밍입장에서 편함 / RISK : 명령어 구조가 단순하여 조합이 적지만 고성능에 적합
		> RISK 가 속도면에서 이점이 있음
		>> 일반적으로 명령어 실행과정에서 fetch decode execution 3단계가 각각 1클럭시 소모됨  
		>> 이를 개별적인 각 단계들을 동시에 진행하여 필요한 클럭수를 줄일 수 있음
### 2. LOAD & STORE 명령어 디자인
- 명령어의 제한
	- 사친연산의 피 연산자는 숫자 or 레지스터
	- 연산결과는 레지스터에 저장
	- 즉 레지스터를 통해서 모든 연산을 진행하겠다
- LOAD 명령어

	`| 예약(2bit) | LOAD(3bit)(110) | destination(3bit) | source(8bit) |`
	> ex) LOAD r1, 0x20
	- destination : 데이터를 저장할 레지스터 정보
	- source : 데이터를 읽어올 메모리의 주소 정보
- STORE 명령어

	`| 예약(2bit) | STORE(3bit)(111) | destination(3bit) | source(8bit) |`
	> ex) STORE r1, 0x20
	- destination : 데이터를 읽어올 레지스터 정보
	- source : 데이터를 저장할 메모리의 주소 정보

### 3. Direct 모드와 Indirect 모드
- Direct 모드의 문제점
	- 명령어 구성의 또 다른 문제점
	``` assembly
	LOAD r1, 0x0010
	LOAD r2, 0x0100 (구성 불가)
	;LOAD 명령어의 source크기가 8bit밖에 안되기 때문에 너무 큰 주소에는 직접접근 불가능
	```
```assembly
;문제해결

LOAD	r1,	0x0010

MUL	r0,	4,	4
MUL	r2,	4,	4
MUL	r3,	r0,	r2
;16 * 16 = 256 = 0x0100
;명령어 상에 0x0100을 표현할 수 있는 방법이 없으므로 레지스터에 0x0100에 해당하는 값을 만들어 레지스터에 담아놓음

STORE	r3,	0x0030
;레지스터에 만들었던 값 메모리에 저장
LOAD	r3,	0x0030
;Indirect모드로 데이터 로드

ADD	r3,	r1,	r2
```
